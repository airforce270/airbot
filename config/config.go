// Package config handles reading the config data.
package config

import (
	"errors"
	"fmt"
	"io"
	"os"

	"github.com/pelletier/go-toml/v2"
)

// fileName contains the name of the config file to be read (when referenced by the binary).
const fileName = "config.toml"

// DefaultNewConfigSource is the default source of the latest config data.
var DefaultNewConfigSource = func() (io.ReadCloser, error) {
	f, err := os.Open(fileName)
	if err != nil {
		return nil, fmt.Errorf("failed to open %q: %w", fileName, err)
	}
	return f, nil
}

// Config is the top-level config object.
type Config struct {
	// LogIncoming is whether the bot should log incoming messages.
	LogIncoming bool `toml:"log_incoming_messages"`
	// LogOutgoing is whether the bot should log outgoing messages.
	LogOutgoing bool `toml:"log_outgoing_messages"`
	// Platforms contains platform-specific config data.
	Platforms PlatformConfig
	// Supinic contains config for talking to the Supinic API.
	Supinic SupinicConfig
}

// PlatformConfig is platform-specific config data.
type PlatformConfig struct {
	// Kick contains Kick-specific config data.
	Kick KickConfig
	// Twitch contains Twitch-specific config data.
	Twitch TwitchConfig
}

// KickConfig is Kick-specific config data.
type KickConfig struct {
	// JA3 is the ja3 value to use for Kick calls.
	JA3 string
	// UserAgent is the user agent to use for Kick calls.
	UserAgent string `toml:"user_agent"`
}

// TwitchConfig is Twitch-specific config data.
type TwitchConfig struct {
	// Enabled is whether Twitch should be connected to and messages handled.
	Enabled bool
	// Username is the Twitch username of the account to use for the bot.
	Username string
	// ClientID is the Twitch Client ID of the bot.
	// Clients can be created here: https://dev.twitch.tv/console
	ClientID string `toml:"client_id"`
	// ClientSecret is the client secret for the Client ID.
	ClientSecret string `toml:"client_secret"`
	// AccessToken is a **user** OAuth2 token generated by Twitch for the bot account.
	// You can generate one using https://twitchtokengenerator.com
	// See here for more info:
	// https://dev.twitch.tv/docs/irc/authenticate-bot#getting-an-access-token
	AccessToken string `toml:"access_token"`
	// RefreshToken is the refresh token for the access token.
	// It should be provided to you when you generate your token
	// using https://twitchtokengenerator.com
	// See here for more info:
	// https://dev.twitch.tv/docs/authentication/refresh-tokens/
	RefreshToken string `toml:"refresh_token"`
	// Owners contains the Twitch usernames of the bot owner(s).
	Owners []string
}

const (
	// placeholderSupinicUserID is the placeholder UserID for the Supinic API.
	// If the user ID is this value, it means the user hasn't configured it.
	placeholderSupinicUserID = "not-required-to-run-bot"
	// placeholderSupinicAPIKey is the placeholder APIKey for the Supinic API.
	// If the API key is this value, it means the user hasn't configured it.
	placeholderSupinicAPIKey = "you-can-safely-leave-this-as-is"
)

// SupinicConfig contains data for talking to the Supinic API.
type SupinicConfig struct {
	// UserID is the Supinic User ID of the bot.
	// https://supinic.com/user/auth-key
	UserID string `toml:"user_id"`
	// APIKey is an authentication key for the bot.
	// https://supinic.com/user/auth-key
	APIKey string `toml:"api_key"`
	// ShouldPingAPI is whether the Supinic API should be pinged from time to time
	// to let the Supinic API know that the bot is alive.
	// Normally, this should only be done by af2bot, the reference instance of Airbot.
	ShouldPingAPI bool `toml:"should_ping_api"`
}

func (s SupinicConfig) IsConfigured() bool {
	hasDefaultValue := s.UserID == placeholderSupinicUserID || s.APIKey == placeholderSupinicAPIKey
	isUnset := s.UserID == "" || s.APIKey == ""
	return !hasDefaultValue && !isUnset
}

// Read reads data into a new config.
func Read(r io.Reader) (*Config, error) {
	decoder := toml.NewDecoder(r).DisallowUnknownFields()
	cfg := Config{}
	if err := decoder.Decode(&cfg); err != nil {
		var details *toml.StrictMissingError
		if errors.As(err, &details) {
			return nil, fmt.Errorf("failed to decode config (%s): %w", details.String(), details)
		}
		return nil, fmt.Errorf("failed to decode config: %w", err)
	}
	return &cfg, nil
}
