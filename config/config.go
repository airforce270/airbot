// Package config handles reading the config data.
package config

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"github.com/pelletier/go-toml/v2"
)

// Name contains the name of the config file to be read (when referenced by the binary).
const Name = "config.toml"

// Config is the top-level config object.
type Config struct {
	// LogIncoming is whether the bot should log incoming messages.
	LogIncoming bool `toml:"log_incoming_messages"`
	// LogOutgoing is whether the bot should log outgoing messages.
	LogOutgoing bool `toml:"log_outgoing_messages"`
	// Platforms contains platform-specific config data.
	Platforms PlatformConfig
	// EnableNonPrefixCommands is whether non-prefix commands should be enabled.
	EnableNonPrefixCommands bool `toml:"enable_non_prefix_commands"`
	// Supinic contains config for talking to the Supinic API.
	Supinic SupinicConfig
}

// PlatformConfig is platform-specific config data.
type PlatformConfig struct {
	// Twitch contains Twitch-specific config data.
	Twitch TwitchConfig
}

// TwitchConfig is Twitch-specific config data.
type TwitchConfig struct {
	// Enabled is whether Twitch should be connected to and messages handled.
	Enabled bool
	// Username is the Twitch username of the account to use for the bot.
	Username string
	// ClientID is the Twitch Client ID of the bot.
	// Clients can be created here: https://dev.twitch.tv/console
	ClientID string `toml:"client_id"`
	// AccessToken is a **user** OAuth2 token generated by Twitch for the bot account.
	// You can generate one using https://twitchtokengenerator.com
	// See here for more info:
	// https://dev.twitch.tv/docs/irc/authenticate-bot#getting-an-access-token
	AccessToken string `toml:"access_token"`
	// Owners contains the Twitch usernames of the bot owner(s).
	Owners []string
}

const (
	// placeholderSupinicUserID is the placeholder UserID for the Supinic API.
	// If the user ID is this value, it means the user hasn't configured it.
	placeholderSupinicUserID = "not-required-to-run-bot"
	// placeholderSupinicAPIKey is the placeholder APIKey for the Supinic API.
	// If the API key is this value, it means the user hasn't configured it.
	placeholderSupinicAPIKey = "you-can-safely-leave-this-as-is"
)

// SupinicConfig contains data for talking to the Supinic API.
type SupinicConfig struct {
	// UserID is the Supinic User ID of the bot.
	// https://supinic.com/user/auth-key
	UserID string `toml:"user_id"`
	// APIKey is an authentication key for the bot.
	// https://supinic.com/user/auth-key
	APIKey string `toml:"api_key"`
	// ShouldPingAPI is whether the Supinic API should be pinged from time to time
	// to let the Supinic API know that the bot is alive.
	// Normally, this should only be done by af2bot, the reference instance of Airbot.
	ShouldPingAPI bool `toml:"should_ping_api"`
}

func (s *SupinicConfig) IsConfigured() bool {
	hasDefaultValue := s.UserID == placeholderSupinicUserID || s.APIKey == placeholderSupinicAPIKey
	isUnset := s.UserID == "" || s.APIKey == ""
	return !hasDefaultValue && !isUnset
}

// Read reads the config data from the given path.
func Read(path string) (*Config, error) {
	raw, err := OSReadFile(path)
	if err != nil {
		return nil, err
	}
	return parse(raw)
}

var (
	OSReadFile = os.ReadFile
)

// parse parses raw bytes into a config.
func parse(data []byte) (*Config, error) {
	decoder := toml.NewDecoder(strings.NewReader(string(data)))
	decoder.DisallowUnknownFields()
	cfg := Config{}
	if err := decoder.Decode(&cfg); err != nil {
		var details *toml.StrictMissingError
		if errors.As(err, &details) {
			return nil, fmt.Errorf("failed to decode config (%s): %w", details.String(), details)
		}
		return nil, err
	}
	return &cfg, nil
}
