// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package database

import (
	"context"
	"time"
)

const countBotBansInChannel = `-- name: CountBotBansInChannel :one
SELECT COUNT(*)
FROM bot_bans
WHERE platform = ?
  AND channel = ?
  AND banned_at > ?
`

type CountBotBansInChannelParams struct {
	Platform *string
	Channel  *string
	BannedAt *time.Time
}

func (q *Queries) CountBotBansInChannel(ctx context.Context, arg CountBotBansInChannelParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countBotBansInChannel, arg.Platform, arg.Channel, arg.BannedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countJoinedChannels = `-- name: CountJoinedChannels :one
SELECT COUNT(*)
FROM joined_channels
`

func (q *Queries) CountJoinedChannels(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJoinedChannels)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMessagesCreatedSince = `-- name: CountMessagesCreatedSince :one
SELECT COUNT(*)
FROM messages
WHERE created_at > ?
`

func (q *Queries) CountMessagesCreatedSince(ctx context.Context, createdAt *time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, countMessagesCreatedSince, createdAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createBotBan = `-- name: CreateBotBan :one


INSERT INTO bot_bans (
  created_at, updated_at,
  platform, channel, banned_at
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, platform, channel, banned_at
`

type CreateBotBanParams struct {
	Platform *string
	Channel  *string
	BannedAt *time.Time
}

// todo: update selects to exclute deleted_at
// todo: update updates to set updated_at
// bot_bans
func (q *Queries) CreateBotBan(ctx context.Context, arg CreateBotBanParams) (BotBan, error) {
	row := q.db.QueryRowContext(ctx, createBotBan, arg.Platform, arg.Channel, arg.BannedAt)
	var i BotBan
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Platform,
		&i.Channel,
		&i.BannedAt,
	)
	return i, err
}

const createChannelCommandCooldown = `-- name: CreateChannelCommandCooldown :one
INSERT INTO channel_command_cooldowns (
  created_at, updated_at,
  channel, command, last_run
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, channel, command, last_run
`

type CreateChannelCommandCooldownParams struct {
	Channel *string
	Command *string
	LastRun *time.Time
}

func (q *Queries) CreateChannelCommandCooldown(ctx context.Context, arg CreateChannelCommandCooldownParams) (ChannelCommandCooldown, error) {
	row := q.db.QueryRowContext(ctx, createChannelCommandCooldown, arg.Channel, arg.Command, arg.LastRun)
	var i ChannelCommandCooldown
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Channel,
		&i.Command,
		&i.LastRun,
	)
	return i, err
}

const createDuel = `-- name: CreateDuel :one

INSERT INTO duels (
  created_at, updated_at,
  user_id, target_id,
  amount,
  pending, accepted,
  won
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?,
  ?,
  ?, ?,
  ?
)
RETURNING id, created_at, updated_at, deleted_at, user_id, target_id, amount, pending, accepted, won
`

type CreateDuelParams struct {
	UserID   *int64
	TargetID *int64
	Amount   *int64
	Pending  *float64
	Accepted *float64
	Won      *float64
}

// duels
func (q *Queries) CreateDuel(ctx context.Context, arg CreateDuelParams) (Duel, error) {
	row := q.db.QueryRowContext(ctx, createDuel,
		arg.UserID,
		arg.TargetID,
		arg.Amount,
		arg.Pending,
		arg.Accepted,
		arg.Won,
	)
	var i Duel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.TargetID,
		&i.Amount,
		&i.Pending,
		&i.Accepted,
		&i.Won,
	)
	return i, err
}

const createGambaTransaction = `-- name: CreateGambaTransaction :one

INSERT INTO gamba_transactions (
  created_at, updated_at,
  user_id, game, delta
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, user_id, game, delta
`

type CreateGambaTransactionParams struct {
	UserID *int64
	Game   *string
	Delta  *int64
}

// gamba_transactions
func (q *Queries) CreateGambaTransaction(ctx context.Context, arg CreateGambaTransactionParams) (GambaTransaction, error) {
	row := q.db.QueryRowContext(ctx, createGambaTransaction, arg.UserID, arg.Game, arg.Delta)
	var i GambaTransaction
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Game,
		&i.Delta,
	)
	return i, err
}

const createJoinedChannel = `-- name: CreateJoinedChannel :one

INSERT INTO joined_channels (
  created_at, updated_at,
  platform,
  channel, channel_id,
  prefix, joined_at
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?,
  ?, ?,
  ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, platform, channel, channel_id, prefix, joined_at
`

type CreateJoinedChannelParams struct {
	Platform  *string
	Channel   *string
	ChannelID *string
	Prefix    *string
	JoinedAt  *time.Time
}

// joined_channels
func (q *Queries) CreateJoinedChannel(ctx context.Context, arg CreateJoinedChannelParams) (JoinedChannel, error) {
	row := q.db.QueryRowContext(ctx, createJoinedChannel,
		arg.Platform,
		arg.Channel,
		arg.ChannelID,
		arg.Prefix,
		arg.JoinedAt,
	)
	var i JoinedChannel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Platform,
		&i.Channel,
		&i.ChannelID,
		&i.Prefix,
		&i.JoinedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one

INSERT INTO messages (
  created_at, updated_at,
  user_id, channel, ` + "`" + `text` + "`" + `, time
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?, ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, ` + "`" + `text` + "`" + `, channel, user_id, time
`

type CreateMessageParams struct {
	UserID  *int64
	Channel *string
	Text    *string
	Time    *time.Time
}

// messages
func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.UserID,
		arg.Channel,
		arg.Text,
		arg.Time,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Text,
		&i.Channel,
		&i.UserID,
		&i.Time,
	)
	return i, err
}

const createTwitchUser = `-- name: CreateTwitchUser :one

INSERT INTO users (
  created_at, updated_at,
  twitch_id, twitch_name
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, twitch_id, twitch_name
`

type CreateTwitchUserParams struct {
	TwitchID   *string
	TwitchName *string
}

// users
func (q *Queries) CreateTwitchUser(ctx context.Context, arg CreateTwitchUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createTwitchUser, arg.TwitchID, arg.TwitchName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TwitchID,
		&i.TwitchName,
	)
	return i, err
}

const createUserCommandCooldown = `-- name: CreateUserCommandCooldown :one
INSERT INTO user_command_cooldowns (
  created_at, updated_at,
  user_id, command, last_run
) VALUES (
  CURRENT_TIMESTAMP, CURRENT_TIMESTAMP,
  ?, ?, ?
)
RETURNING id, created_at, updated_at, deleted_at, user_id, command, last_run
`

type CreateUserCommandCooldownParams struct {
	UserID  *int64
	Command *string
	LastRun *time.Time
}

func (q *Queries) CreateUserCommandCooldown(ctx context.Context, arg CreateUserCommandCooldownParams) (UserCommandCooldown, error) {
	row := q.db.QueryRowContext(ctx, createUserCommandCooldown, arg.UserID, arg.Command, arg.LastRun)
	var i UserCommandCooldown
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Command,
		&i.LastRun,
	)
	return i, err
}

const deleteAllDuelsForTest = `-- name: DeleteAllDuelsForTest :exec
DELETE FROM duels
`

func (q *Queries) DeleteAllDuelsForTest(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllDuelsForTest)
	return err
}

const deleteAllGambaTransactionsForTest = `-- name: DeleteAllGambaTransactionsForTest :exec
DELETE FROM gamba_transactions
`

func (q *Queries) DeleteAllGambaTransactionsForTest(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllGambaTransactionsForTest)
	return err
}

const deleteAllUsersForTest = `-- name: DeleteAllUsersForTest :exec
DELETE FROM users
`

func (q *Queries) DeleteAllUsersForTest(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllUsersForTest)
	return err
}

const finalizeDuel = `-- name: FinalizeDuel :exec
UPDATE duels
SET pending = ?, accepted = ?, won = ?
WHERE user_id = ?
  AND target_id = ?
`

type FinalizeDuelParams struct {
	Pending  *float64
	Accepted *float64
	Won      *float64
	UserID   *int64
	TargetID *int64
}

func (q *Queries) FinalizeDuel(ctx context.Context, arg FinalizeDuelParams) error {
	_, err := q.db.ExecContext(ctx, finalizeDuel,
		arg.Pending,
		arg.Accepted,
		arg.Won,
		arg.UserID,
		arg.TargetID,
	)
	return err
}

const leaveChannel = `-- name: LeaveChannel :execrows
UPDATE joined_channels
SET deleted_at = CURRENT_TIMESTAMP
WHERE platform = ? AND channel = ?
`

type LeaveChannelParams struct {
	Platform *string
	Channel  *string
}

func (q *Queries) LeaveChannel(ctx context.Context, arg LeaveChannelParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, leaveChannel, arg.Platform, arg.Channel)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const selectActiveUsers = `-- name: SelectActiveUsers :many
SELECT id, created_at, updated_at, deleted_at, twitch_id, twitch_name
FROM users
WHERE id IN (
    SELECT DISTINCT m.user_id
    FROM messages AS m
    WHERE m.time > ?
  )
`

func (q *Queries) SelectActiveUsers(ctx context.Context, argTime *time.Time) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, selectActiveUsers, argTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TwitchID,
			&i.TwitchName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllGambaTransactions = `-- name: SelectAllGambaTransactions :many
SELECT id, created_at, updated_at, deleted_at, user_id, game, delta
FROM gamba_transactions
`

func (q *Queries) SelectAllGambaTransactions(ctx context.Context) ([]GambaTransaction, error) {
	rows, err := q.db.QueryContext(ctx, selectAllGambaTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GambaTransaction
	for rows.Next() {
		var i GambaTransaction
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.Game,
			&i.Delta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectCacheBoolItem = `-- name: SelectCacheBoolItem :one

SELECT created_at, updated_at, keyy, value, expires_at
FROM cache_bool_items
WHERE keyy = ?
`

// cache_bool_item
func (q *Queries) SelectCacheBoolItem(ctx context.Context, keyy *string) (CacheBoolItem, error) {
	row := q.db.QueryRowContext(ctx, selectCacheBoolItem, keyy)
	var i CacheBoolItem
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Keyy,
		&i.Value,
		&i.ExpiresAt,
	)
	return i, err
}

const selectCacheStringItem = `-- name: SelectCacheStringItem :one

SELECT created_at, updated_at, keyy, value, expires_at
FROM cache_string_items
WHERE keyy = ?
`

// cache_string_items
func (q *Queries) SelectCacheStringItem(ctx context.Context, keyy *string) (CacheStringItem, error) {
	row := q.db.QueryRowContext(ctx, selectCacheStringItem, keyy)
	var i CacheStringItem
	err := row.Scan(
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Keyy,
		&i.Value,
		&i.ExpiresAt,
	)
	return i, err
}

const selectChannelCommandCooldown = `-- name: SelectChannelCommandCooldown :one

SELECT id, created_at, updated_at, deleted_at, channel, command, last_run
FROM channel_command_cooldowns
WHERE channel = ?
  AND command = ?
`

type SelectChannelCommandCooldownParams struct {
	Channel *string
	Command *string
}

// channel_command_cooldowns
func (q *Queries) SelectChannelCommandCooldown(ctx context.Context, arg SelectChannelCommandCooldownParams) (ChannelCommandCooldown, error) {
	row := q.db.QueryRowContext(ctx, selectChannelCommandCooldown, arg.Channel, arg.Command)
	var i ChannelCommandCooldown
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Channel,
		&i.Command,
		&i.LastRun,
	)
	return i, err
}

const selectJoinedChannel = `-- name: SelectJoinedChannel :one
SELECT id, created_at, updated_at, deleted_at, platform, channel, channel_id, prefix, joined_at
FROM joined_channels
WHERE platform = ? AND channel = ?
`

type SelectJoinedChannelParams struct {
	Platform *string
	Channel  *string
}

func (q *Queries) SelectJoinedChannel(ctx context.Context, arg SelectJoinedChannelParams) (JoinedChannel, error) {
	row := q.db.QueryRowContext(ctx, selectJoinedChannel, arg.Platform, arg.Channel)
	var i JoinedChannel
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Platform,
		&i.Channel,
		&i.ChannelID,
		&i.Prefix,
		&i.JoinedAt,
	)
	return i, err
}

const selectJoinedChannels = `-- name: SelectJoinedChannels :many
SELECT id, created_at, updated_at, deleted_at, platform, channel, channel_id, prefix, joined_at
FROM joined_channels
WHERE platform = ?
`

func (q *Queries) SelectJoinedChannels(ctx context.Context, platform *string) ([]JoinedChannel, error) {
	rows, err := q.db.QueryContext(ctx, selectJoinedChannels, platform)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JoinedChannel
	for rows.Next() {
		var i JoinedChannel
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Platform,
			&i.Channel,
			&i.ChannelID,
			&i.Prefix,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTwitchUser = `-- name: SelectTwitchUser :one
SELECT id, created_at, updated_at, deleted_at, twitch_id, twitch_name
FROM users
WHERE twitch_id = ? AND twitch_name = ?
`

type SelectTwitchUserParams struct {
	TwitchID   *string
	TwitchName *string
}

func (q *Queries) SelectTwitchUser(ctx context.Context, arg SelectTwitchUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, selectTwitchUser, arg.TwitchID, arg.TwitchName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TwitchID,
		&i.TwitchName,
	)
	return i, err
}

const selectTwitchUserByTwitchName = `-- name: SelectTwitchUserByTwitchName :one
SELECT id, created_at, updated_at, deleted_at, twitch_id, twitch_name
FROM users
WHERE twitch_name = ?
`

func (q *Queries) SelectTwitchUserByTwitchName(ctx context.Context, twitchName *string) (User, error) {
	row := q.db.QueryRowContext(ctx, selectTwitchUserByTwitchName, twitchName)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TwitchID,
		&i.TwitchName,
	)
	return i, err
}

const selectUserByID = `-- name: SelectUserByID :one
SELECT id, created_at, updated_at, deleted_at, twitch_id, twitch_name
FROM users
WHERE id = ?
`

func (q *Queries) SelectUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, selectUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TwitchID,
		&i.TwitchName,
	)
	return i, err
}

const selectUserCommandCooldown = `-- name: SelectUserCommandCooldown :one

SELECT id, created_at, updated_at, deleted_at, user_id, command, last_run
FROM user_command_cooldowns
WHERE user_id = ?
  AND command = ?
`

type SelectUserCommandCooldownParams struct {
	UserID  *int64
	Command *string
}

// user_command_cooldowns
func (q *Queries) SelectUserCommandCooldown(ctx context.Context, arg SelectUserCommandCooldownParams) (UserCommandCooldown, error) {
	row := q.db.QueryRowContext(ctx, selectUserCommandCooldown, arg.UserID, arg.Command)
	var i UserCommandCooldown
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.Command,
		&i.LastRun,
	)
	return i, err
}

const selectUserInboundDuels = `-- name: SelectUserInboundDuels :many
SELECT id, created_at, updated_at, deleted_at, user_id, target_id, amount, pending, accepted, won
FROM duels
WHERE target_id = ? AND created_at >= ?
`

type SelectUserInboundDuelsParams struct {
	TargetID  *int64
	CreatedAt *time.Time
}

func (q *Queries) SelectUserInboundDuels(ctx context.Context, arg SelectUserInboundDuelsParams) ([]Duel, error) {
	rows, err := q.db.QueryContext(ctx, selectUserInboundDuels, arg.TargetID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.TargetID,
			&i.Amount,
			&i.Pending,
			&i.Accepted,
			&i.Won,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserOutboundDuels = `-- name: SelectUserOutboundDuels :many
SELECT id, created_at, updated_at, deleted_at, user_id, target_id, amount, pending, accepted, won
FROM duels
WHERE user_id = ? AND created_at >= ?
`

type SelectUserOutboundDuelsParams struct {
	UserID    *int64
	CreatedAt *time.Time
}

func (q *Queries) SelectUserOutboundDuels(ctx context.Context, arg SelectUserOutboundDuelsParams) ([]Duel, error) {
	rows, err := q.db.QueryContext(ctx, selectUserOutboundDuels, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Duel
	for rows.Next() {
		var i Duel
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.TargetID,
			&i.Amount,
			&i.Pending,
			&i.Accepted,
			&i.Won,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUserPoints = `-- name: SelectUserPoints :one
SELECT CAST(COALESCE(SUM(delta)) AS INTEGER)
FROM gamba_transactions
WHERE user_id = ?
`

func (q *Queries) SelectUserPoints(ctx context.Context, userID *int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, selectUserPoints, userID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const setChannelCommandCooldownLastRun = `-- name: SetChannelCommandCooldownLastRun :exec
UPDATE channel_command_cooldowns
SET last_run = ?
WHERE channel = ?
  AND command = ?
`

type SetChannelCommandCooldownLastRunParams struct {
	LastRun *time.Time
	Channel *string
	Command *string
}

func (q *Queries) SetChannelCommandCooldownLastRun(ctx context.Context, arg SetChannelCommandCooldownLastRunParams) error {
	_, err := q.db.ExecContext(ctx, setChannelCommandCooldownLastRun, arg.LastRun, arg.Channel, arg.Command)
	return err
}

const setJoinedChannelPrefix = `-- name: SetJoinedChannelPrefix :execrows
UPDATE joined_channels
SET prefix = ?
WHERE platform = ? AND channel = ?
`

type SetJoinedChannelPrefixParams struct {
	Prefix   *string
	Platform *string
	Channel  *string
}

func (q *Queries) SetJoinedChannelPrefix(ctx context.Context, arg SetJoinedChannelPrefixParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, setJoinedChannelPrefix, arg.Prefix, arg.Platform, arg.Channel)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setUserCommandCooldownLastRun = `-- name: SetUserCommandCooldownLastRun :exec
UPDATE user_command_cooldowns
SET last_run = ?
WHERE user_id = ?
  AND command = ?
`

type SetUserCommandCooldownLastRunParams struct {
	LastRun *time.Time
	UserID  *int64
	Command *string
}

func (q *Queries) SetUserCommandCooldownLastRun(ctx context.Context, arg SetUserCommandCooldownLastRunParams) error {
	_, err := q.db.ExecContext(ctx, setUserCommandCooldownLastRun, arg.LastRun, arg.UserID, arg.Command)
	return err
}

const updateJoinedChannelName = `-- name: UpdateJoinedChannelName :exec
UPDATE joined_channels
SET channel = ?
WHERE channel_id = ?
`

type UpdateJoinedChannelNameParams struct {
	Channel   *string
	ChannelID *string
}

func (q *Queries) UpdateJoinedChannelName(ctx context.Context, arg UpdateJoinedChannelNameParams) error {
	_, err := q.db.ExecContext(ctx, updateJoinedChannelName, arg.Channel, arg.ChannelID)
	return err
}

const updateTwitchUserName = `-- name: UpdateTwitchUserName :one
UPDATE users
SET twitch_name = ?
WHERE twitch_id = ?
RETURNING id, created_at, updated_at, deleted_at, twitch_id, twitch_name
`

type UpdateTwitchUserNameParams struct {
	TwitchName *string
	TwitchID   *string
}

func (q *Queries) UpdateTwitchUserName(ctx context.Context, arg UpdateTwitchUserNameParams) (User, error) {
	row := q.db.QueryRowContext(ctx, updateTwitchUserName, arg.TwitchName, arg.TwitchID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.TwitchID,
		&i.TwitchName,
	)
	return i, err
}

const upsertCacheBoolItem = `-- name: UpsertCacheBoolItem :exec
INSERT INTO cache_bool_items
(keyy, value, expires_at)
VALUES (?, ?, ?)
ON CONFLICT (keyy)
DO UPDATE SET value = ?, expires_at = ?
`

type UpsertCacheBoolItemParams struct {
	Keyy      *string
	Value     *float64
	ExpiresAt *time.Time
}

func (q *Queries) UpsertCacheBoolItem(ctx context.Context, arg UpsertCacheBoolItemParams) error {
	_, err := q.db.ExecContext(ctx, upsertCacheBoolItem, arg.Keyy, arg.Value, arg.ExpiresAt)
	return err
}

const upsertCacheStringItem = `-- name: UpsertCacheStringItem :exec
INSERT INTO cache_string_items
(keyy, value, expires_at)
VALUES (?, ?, ?)
ON CONFLICT (keyy)
DO UPDATE SET value = ?, expires_at = ?
`

type UpsertCacheStringItemParams struct {
	Keyy      *string
	Value     *string
	ExpiresAt *time.Time
}

func (q *Queries) UpsertCacheStringItem(ctx context.Context, arg UpsertCacheStringItemParams) error {
	_, err := q.db.ExecContext(ctx, upsertCacheStringItem, arg.Keyy, arg.Value, arg.ExpiresAt)
	return err
}
